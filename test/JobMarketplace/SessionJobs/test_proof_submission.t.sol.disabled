// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../../src/JobMarketplaceFABWithS5.sol";
import "../../../src/NodeRegistryFAB.sol";

contract ProofSubmissionTest is Test {
    JobMarketplaceFABWithS5 public marketplace;
    NodeRegistryFAB public nodeRegistry;
    MockProofSystem public proofSystem;
    
    address public host = address(0x1);
    address public renter = address(0x2);
    uint256 public jobId;
    
    event ProofSubmitted(
        uint256 indexed jobId,
        address indexed host,
        uint256 tokensClaimed,
        bytes32 proofHash,
        bool verified
    );
    
    function setUp() public {
        nodeRegistry = new NodeRegistryFAB();
        marketplace = new JobMarketplaceFABWithS5(address(nodeRegistry), payable(address(0x3)));
        proofSystem = new MockProofSystem();
        marketplace.setProofSystem(address(proofSystem));
        
        // Register host
        vm.deal(host, 101 ether);
        vm.prank(host);
        nodeRegistry.registerNode{value: 100 ether}("node1", "region1");
        
        // Create session job
        vm.deal(renter, 2 ether);
        vm.prank(renter);
        jobId = marketplace.createSessionJob{value: 1 ether}(
            host,
            1 ether,
            0.001 ether,
            1 days,
            100
        );
    }
    
    function test_SuccessfulProofSubmission() public {
        bytes memory proof = abi.encode("proof_data");
        uint256 tokens = 100;
        
        vm.prank(host);
        bool verified = marketplace.submitProofOfWork(jobId, proof, tokens);
        
        assertTrue(verified, "Proof should be verified");
        assertEq(marketplace.getProvenTokens(jobId), tokens, "Proven tokens should be updated");
    }
    
    function test_ProofHashStorage() public {
        bytes memory proof = abi.encode("unique_proof");
        uint256 tokens = 50;
        
        vm.prank(host);
        marketplace.submitProofOfWork(jobId, proof, tokens);
        
        JobMarketplaceFABWithS5.ProofSubmission[] memory submissions = marketplace.getProofSubmissions(jobId);
        assertEq(submissions.length, 1, "Should have one submission");
        assertEq(submissions[0].proofHash, keccak256(proof), "Proof hash should match");
    }
    
    function test_TokenCountUpdates() public {
        bytes memory proof1 = abi.encode("proof1");
        bytes memory proof2 = abi.encode("proof2");
        
        vm.prank(host);
        marketplace.submitProofOfWork(jobId, proof1, 100);
        
        vm.prank(host);
        marketplace.submitProofOfWork(jobId, proof2, 150);
        
        assertEq(marketplace.getProvenTokens(jobId), 250, "Total tokens should accumulate");
    }
    
    function test_EventEmission() public {
        bytes memory proof = abi.encode("test_proof");
        uint256 tokens = 75;
        
        vm.expectEmit(true, true, false, true);
        emit ProofSubmitted(jobId, host, tokens, keccak256(proof), true);
        
        vm.prank(host);
        marketplace.submitProofOfWork(jobId, proof, tokens);
    }
}

contract MockProofSystem {
    function verifyEKZL(
        bytes calldata,
        address,
        uint256
    ) external pure returns (bool) {
        return true;
    }
}