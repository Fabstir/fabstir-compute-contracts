// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../../src/JobMarketplaceFABWithS5.sol";
import "../../../src/NodeRegistryFAB.sol";

contract InvalidProofsTest is Test {
    JobMarketplaceFABWithS5 public marketplace;
    NodeRegistryFAB public nodeRegistry;
    MockProofSystem public proofSystem;
    
    address public host = address(0x1);
    address public otherHost = address(0x2);
    address public renter = address(0x3);
    uint256 public jobId;
    
    function setUp() public {
        nodeRegistry = new NodeRegistryFAB();
        marketplace = new JobMarketplaceFABWithS5(address(nodeRegistry), payable(address(0x4)));
        proofSystem = new MockProofSystem();
        marketplace.setProofSystem(address(proofSystem));
        
        // Register hosts
        vm.deal(host, 101 ether);
        vm.prank(host);
        nodeRegistry.registerNode{value: 100 ether}("node1", "region1");
        
        vm.deal(otherHost, 101 ether);
        vm.prank(otherHost);
        nodeRegistry.registerNode{value: 100 ether}("node2", "region2");
        
        // Create session job
        vm.deal(renter, 2 ether);
        vm.prank(renter);
        jobId = marketplace.createSessionJob{value: 1 ether}(
            host,
            1 ether,
            0.001 ether,
            1 days,
            100
        );
    }
    
    function test_RejectionOfInvalidProofs() public {
        proofSystem.setShouldFail(true);
        
        bytes memory proof = abi.encode("invalid_proof");
        
        vm.prank(host);
        bool verified = marketplace.submitProofOfWork(jobId, proof, 100);
        
        assertFalse(verified, "Invalid proof should not verify");
        assertEq(marketplace.getProvenTokens(jobId), 0, "No tokens should be proven");
    }
    
    function test_UnauthorizedHostRejection() public {
        bytes memory proof = abi.encode("proof");
        
        // Other host tries to submit proof
        vm.prank(otherHost);
        vm.expectRevert("Not assigned host");
        marketplace.submitProofOfWork(jobId, proof, 100);
        
        // Random address tries
        vm.prank(address(0x999));
        vm.expectRevert("Not assigned host");
        marketplace.submitProofOfWork(jobId, proof, 100);
    }
    
    function test_InactiveSessionRejection() public {
        // Complete the session first
        vm.prank(host);
        marketplace.completeSession(jobId);
        
        bytes memory proof = abi.encode("proof");
        
        vm.prank(host);
        vm.expectRevert("Session not active");
        marketplace.submitProofOfWork(jobId, proof, 100);
    }
    
    function test_NonExistentJobRejection() public {
        bytes memory proof = abi.encode("proof");
        uint256 fakeJobId = 999;
        
        vm.prank(host);
        vm.expectRevert("Job does not exist");
        marketplace.submitProofOfWork(fakeJobId, proof, 100);
    }
    
    function test_ZeroTokenSubmission() public {
        bytes memory proof = abi.encode("proof");
        
        vm.prank(host);
        vm.expectRevert("Tokens must be positive");
        marketplace.submitProofOfWork(jobId, proof, 0);
    }
    
    function test_EmptyProofRejection() public {
        bytes memory emptyProof = "";
        
        vm.prank(host);
        vm.expectRevert("Proof required");
        marketplace.submitProofOfWork(jobId, emptyProof, 100);
    }
    
    function test_ExcessiveTokenClaim() public {
        bytes memory proof = abi.encode("proof");
        uint256 maxTokens = 1 ether / 0.001 ether; // Max possible tokens
        
        vm.prank(host);
        vm.expectRevert("Exceeds deposit capacity");
        marketplace.submitProofOfWork(jobId, proof, maxTokens + 1);
    }
    
    function test_ProofAfterMaxTokensReached() public {
        // Submit proofs up to max
        uint256 maxTokens = 1000; // 1 ether / 0.001 ether
        
        vm.prank(host);
        marketplace.submitProofOfWork(jobId, abi.encode("proof1"), maxTokens);
        
        // Try to submit more
        vm.prank(host);
        vm.expectRevert("Max tokens already proven");
        marketplace.submitProofOfWork(jobId, abi.encode("proof2"), 1);
    }
}

contract MockProofSystem {
    bool public shouldFail = false;
    
    function setShouldFail(bool _shouldFail) external {
        shouldFail = _shouldFail;
    }
    
    function verifyEKZL(
        bytes calldata,
        address,
        uint256
    ) external view returns (bool) {
        return !shouldFail;
    }
}

// Mock function for session completion (will be implemented later)
contract JobMarketplaceFABWithS5Mock {
    function completeSession(uint256) external pure {
        // Mock implementation
    }
}