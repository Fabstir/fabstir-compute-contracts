// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../../src/JobMarketplaceFABWithS5.sol";
import "../../../src/NodeRegistryFAB.sol";

contract ProofTrackingTest is Test {
    JobMarketplaceFABWithS5 public marketplace;
    NodeRegistryFAB public nodeRegistry;
    MockProofSystem public proofSystem;
    
    address public host = address(0x1);
    address public renter = address(0x2);
    uint256 public jobId;
    
    function setUp() public {
        nodeRegistry = new NodeRegistryFAB();
        marketplace = new JobMarketplaceFABWithS5(address(nodeRegistry), payable(address(0x3)));
        proofSystem = new MockProofSystem();
        marketplace.setProofSystem(address(proofSystem));
        
        // Register host
        vm.deal(host, 101 ether);
        vm.prank(host);
        nodeRegistry.registerNode{value: 100 ether}("node1", "region1");
        
        // Create session job
        vm.deal(renter, 2 ether);
        vm.prank(renter);
        jobId = marketplace.createSessionJob{value: 1 ether}(
            host,
            1 ether,
            0.001 ether,
            1 days,
            100
        );
    }
    
    function test_ProofHistoryStorage() public {
        // Submit multiple proofs
        vm.startPrank(host);
        marketplace.submitProofOfWork(jobId, abi.encode("proof1"), 100);
        marketplace.submitProofOfWork(jobId, abi.encode("proof2"), 150);
        marketplace.submitProofOfWork(jobId, abi.encode("proof3"), 200);
        vm.stopPrank();
        
        JobMarketplaceFABWithS5.ProofSubmission[] memory submissions = marketplace.getProofSubmissions(jobId);
        assertEq(submissions.length, 3, "Should store all submissions");
        
        // Verify each submission
        assertEq(submissions[0].tokensClaimed, 100, "First tokens");
        assertEq(submissions[1].tokensClaimed, 150, "Second tokens");
        assertEq(submissions[2].tokensClaimed, 200, "Third tokens");
        
        // Check timestamps are set
        assertTrue(submissions[0].timestamp > 0, "Timestamp should be set");
        assertTrue(submissions[1].timestamp >= submissions[0].timestamp, "Timestamps should be ordered");
    }
    
    function test_ProvenTokenAccumulation() public {
        assertEq(marketplace.getProvenTokens(jobId), 0, "Should start at 0");
        
        vm.prank(host);
        marketplace.submitProofOfWork(jobId, abi.encode("proof1"), 100);
        assertEq(marketplace.getProvenTokens(jobId), 100, "Should have 100");
        
        vm.prank(host);
        marketplace.submitProofOfWork(jobId, abi.encode("proof2"), 150);
        assertEq(marketplace.getProvenTokens(jobId), 250, "Should accumulate to 250");
        
        vm.prank(host);
        marketplace.submitProofOfWork(jobId, abi.encode("proof3"), 200);
        assertEq(marketplace.getProvenTokens(jobId), 450, "Should accumulate to 450");
    }
    
    function test_ProofRetrieval() public {
        bytes memory proof1 = abi.encode("unique_proof_1");
        bytes memory proof2 = abi.encode("unique_proof_2");
        
        vm.prank(host);
        marketplace.submitProofOfWork(jobId, proof1, 100);
        
        vm.prank(host);
        marketplace.submitProofOfWork(jobId, proof2, 200);
        
        JobMarketplaceFABWithS5.ProofSubmission[] memory submissions = marketplace.getProofSubmissions(jobId);
        
        assertEq(submissions[0].proofHash, keccak256(proof1), "First proof hash");
        assertEq(submissions[1].proofHash, keccak256(proof2), "Second proof hash");
        assertEq(submissions[0].tokensClaimed, 100, "First token count");
        assertEq(submissions[1].tokensClaimed, 200, "Second token count");
    }
    
    function test_AggregateProofHashUpdates() public {
        // Get initial session state
        (,,,,,, uint256 provenBefore,,bytes32 hashBefore,) = marketplace.sessions(jobId);
        assertEq(provenBefore, 0, "Should start with 0 proven tokens");
        assertEq(hashBefore, bytes32(0), "Should start with empty hash");
        
        // Submit proof
        vm.prank(host);
        marketplace.submitProofOfWork(jobId, abi.encode("proof1"), 100);
        
        // Check aggregate hash is updated
        (,,,,,, uint256 provenAfter,,bytes32 hashAfter,) = marketplace.sessions(jobId);
        assertEq(provenAfter, 100, "Proven tokens should update");
        assertTrue(hashAfter != bytes32(0), "Aggregate hash should be set");
    }
    
    function test_LastProofSubmissionTracking() public {
        // Submit first proof
        vm.prank(host);
        marketplace.submitProofOfWork(jobId, abi.encode("proof1"), 100);
        
        (,,,,,,, uint256 lastSubmission1,,) = marketplace.sessions(jobId);
        assertTrue(lastSubmission1 > 0, "Should track submission time");
        
        // Wait and submit second proof
        vm.warp(block.timestamp + 100);
        vm.prank(host);
        marketplace.submitProofOfWork(jobId, abi.encode("proof2"), 150);
        
        (,,,,,,, uint256 lastSubmission2,,) = marketplace.sessions(jobId);
        assertTrue(lastSubmission2 > lastSubmission1, "Should update submission time");
    }
}

contract MockProofSystem {
    function verifyEKZL(
        bytes calldata,
        address,
        uint256
    ) external pure returns (bool) {
        return true;
    }
}